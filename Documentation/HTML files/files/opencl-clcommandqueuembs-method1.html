<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Frameset//EN" >
<HTML>
<HEAD>
<TITLE>Monkeybread Xojo plugin - CLCommandQueueMBS methods</TITLE>
<script src="../platforms.js" type="text/javascript"></script>
<link rel="stylesheet" type="text/css" href="../help.css" >
<link rel="stylesheet" type="text/css" href="../screen.css" media="screen">
<link rel="stylesheet" type="text/css" href="../print.css" media="print">
<link rel="stylesheet" type="text/css" href="../allitems.css" title="Default">
<link rel="alternate stylesheet" type="text/css" href="../macitems.css" title="Mac">
<link rel="alternate stylesheet" type="text/css" href="../winitems.css" title="Win">
<link rel="alternate stylesheet" type="text/css" href="../linuxitems.css" title="Linux">
<link rel="alternate stylesheet" type="text/css" href="../crossitems.css" title="Crossplatform">
<meta http-equiv="content-type" content="text/html; charset=x-mac-roman">
<META NAME="description" CONTENT="CLCommandQueueMBS">
</head>
<BODY BGCOLOR="#FFFFFF">
<H2 lang="en">CLCommandQueueMBS methods</h2>
<p><a href="http://www.monkeybreadsoftware.net">Online Documentation</a> &nbsp; - &nbsp; <a href="stats.html">Statistics</a> &nbsp; - &nbsp; <a href="topic-faq.html">FAQ</a> &nbsp; - &nbsp; <a href="parts.html">Plugin Parts</a> (<a href="partsall.html">All</a>, <a href="plugindeps.html">Dependencies</a>) &nbsp; - &nbsp; <a href="hierarchy.html">Class hierarchy</a></p>
<p>New in Version 
<a href="newinversion213.html">21.3</a> 
<a href="newinversion214.html">21.4</a> 
<a href="newinversion215.html">21.5</a> 
<a href="newinversion220.html">22.0</a> 
<a href="newinversion221.html">22.1</a> 
<a href="newinversion222.html">22.2</a> 
<a href="newinversion223.html">22.3</a> 
<a href="newinversion224.html">22.4</a> 
<a href="newinversion225.html">22.5</a> 
<a href="newinversion230.html">23.0</a> 
<a href="newinversion231.html">23.1</a> 
<a href="newinversion232.html">23.2</a> 
</p>
<p>The list of the &nbsp; <a href="themes.html">topics</a>, 
 &nbsp; <a href="classes.html">classes</a>,
 &nbsp; <a href="interfaces.html">interfaces</a>,
 &nbsp; <a href="controls.html">controls</a>,
 &nbsp; <a href="modules.html">modules</a>,
 &nbsp; <a href="globaltopic.html">global methods by category</a>,
 &nbsp; <a href="globalname.html">global methods by name</a>,
 &nbsp; <a href="screenshots.html">screenshots</a>,
 &nbsp; <a href="licenses.html">licenses</a> &nbsp;
 and &nbsp; <a href="examples.html">examples</a>.</p>
<p id=PlatformChooserMBS>Platforms to show: <a class="isA" href="javascript:all();">All</a> <a class="isM" href="javascript:mac();">Mac</a> <a class="isW" href="javascript:win();">Windows</a> <a class="isL" href="javascript:linux();">Linux</a> <a class="isC" href="javascript:crossplatform();">Cross-Platform</a></p>
<p>Back to <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</a> class.  </p>
<p>
<a href="opencl-clcommandqueuembs-method.html">Previous items</a>
 
</p>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="1">EnqueueReadBuffer(buffer as <A href="class-clmemmbs.html">CLMemMBS</A>, offset as Integer, size as Integer, mem as Memoryblock)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueue commands to read from a buffer object to host memory.<BR>
<B>Notes:</B> 
<BR>
buffer: Refers to a valid buffer object.<BR>
BlockingRead: Optional, Indicates if the read operations are blocking or non-blocking. If BlockingRead is true i.e. the read command is blocking, clEnqueueReadBuffer does not return until the buffer data has been read and copied into memory pointed to by ptr.<BR>
<BR>
If BlockingRead is false i.e. the read command is non-blocking, EnqueueReadBuffer queues a non-blocking read command and returns. The contents of the buffer that ptr points to cannot be used until the read command has completed. The event argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that ptr points to can be used by the application.<BR>
<BR>
offset: The offset in bytes in the buffer object to read from.<BR>
size: The size in bytes of data being read.<BR>
mem: The pointer to buffer in host memory where data is to be read into.<BR>
<BR>
EventWaitList: Optional, specifies events that need to complete before this particular command can be executed. If EventWaitList is empty or not passed, then this particular command does not wait on any event to complete. The events specified in EventWaitList act as synchronization points. The context associated with events in EventWaitList and command_queue must be the same.<BR>
<BR>
outEvent: Optional, Returns an event object that identifies this particular read command and can be used to query or queue a wait for this particular command to complete. <BR>
<BR>
Calling EnqueueReadBuffer to read a region of the buffer object with the ptr argument value set to mem + offset, where mem is a pointer to the memory region specified when the buffer object being read is created with kMemoryUseHostPtr, must meet the following requirements in order to avoid undefined behavior:<BR>
<BR>
All commands that use this buffer object have finished execution before the read command begins execution<BR>
The buffer object is not mapped<BR>
The buffer object is not used by any command-queue until the read command has finished execution<BR>
<BR>
Lasterror is set.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method.html#22">EnqueueReadBuffer(buffer as CLMemMBS, BlockingRead as boolean, offset as Integer, size as Integer, mem as Memoryblock, EventWaitList() as CLEventMBS, byref outEvent as CLEventMBS)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="2">EnqueueReadImage(image as <A href="class-clmemmbs.html">CLMemMBS</A>, BlockingRead as boolean, sourceOriginX as Integer, sourceOriginY as Integer, sourceOriginZ as Integer, RegionWidth as Integer, RegionHeight as Integer, RegionDepth as Integer, RowPitch as Integer, SlicePitch as Integer, mem as Memoryblock, EventWaitList() as <A href="class-cleventmbs.html">CLEventMBS</A>, byref outEvent as <A href="class-cleventmbs.html">CLEventMBS</A>)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to read from a 2D or 3D image object to host memory.<BR>
<B>Notes:</B> 
<BR>
image: Refers to a valid 2D or 3D image object.<BR>
<BR>
BlockingRead: Optional. Indicates if the read operations are blocking or non-blocking.<BR>
<BR>
If BlockingRead is true i.e. the read command is blocking, clEnqueueReadImage does not return until the buffer data has been read and copied into memory pointed to by mem.<BR>
<BR>
If BlockingRead is false i.e. map operation is non-blocking, clEnqueueReadImage queues a non-blocking read command and returns. The contents of the buffer that mem points to cannot be used until the read command has completed. The event argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that mem points to can be used by the application.<BR>
<BR>
origin: Defines the (x, y, z) offset in pixels in the image from where to read. If image is a 2D image object, the z value given by sourceOriginZ must be 0.<BR>
<BR>
region: Defines the (width, height, depth) in pixels of the 2D or 3D rectangle being read. If image is a 2D image object, the depth value given by RegionDepth must be 1.<BR>
<BR>
RowPitch: The length of each row in bytes. This value must be greater than or equal to the element size in bytes * width. If RowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width.<BR>
<BR>
SlicePitch: Size in bytes of the 2D slice of the 3D region of a 3D image being read. This must be 0 if image is a 2D image. This value must be greater than or equal to RowPitch * height. If SlicePitch is set to 0, the appropriate slice pitch is calculated based on the RowPitch * height.<BR>
<BR>
mem: The pointer to a buffer in host memory where image data is to be read from.<BR>
<BR>
EventWaitList: Optional, Specify events that need to complete before this particular command can be executed. The events specified in event_wait_list act as synchronization points. The context associated with events in event_wait_list and command_queue must be the same.<BR>
<BR>
outEvent: Optional, Returns an event object that identifies this particular read command and can be used to query or queue a wait for this particular command to complete. event can be nil in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete.<BR>
<BR>
Calling EnqueueReadImage to read a region of the image object with the mem argument value set to HostPtr + (sourceOriginZ * image slice pitch + sourceOriginY * image row pitch + sourceOriginX * bytes per pixel), where host_ptr is a pointer to the memory region specified when the image object being read is created with kMemoryUseHostPtr, must meet the following requirements in order to avoid undefined behavior:<BR>
<BR>
<UL><LI>
All commands that use this image object have finished execution before the read command begins execution.
</LI><LI>
The RowPitch and SlicePitch argument values in EnqueueReadImage must be set to the image row pitch and slice pitch.
</LI><LI>
The image object is not mapped.
</LI><LI>
The image object is not used by any command-queue until the read command has finished execution.
</LI></UL>
<BR>
Lasterror is set.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#3">EnqueueReadImage(image as CLMemMBS, sourceOriginX as Integer, sourceOriginY as Integer, sourceOriginZ as Integer, RegionWidth as Integer, RegionHeight as Integer, RegionDepth as Integer, RowPitch as Integer, SlicePitch as Integer, mem as Memoryblock)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="3">EnqueueReadImage(image as <A href="class-clmemmbs.html">CLMemMBS</A>, sourceOriginX as Integer, sourceOriginY as Integer, sourceOriginZ as Integer, RegionWidth as Integer, RegionHeight as Integer, RegionDepth as Integer, RowPitch as Integer, SlicePitch as Integer, mem as Memoryblock)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to read from a 2D or 3D image object to host memory..<BR>
<B>Notes:</B> 
<BR>
image: Refers to a valid 2D or 3D image object.<BR>
<BR>
BlockingRead: Optional. Indicates if the read operations are blocking or non-blocking.<BR>
<BR>
If BlockingRead is true i.e. the read command is blocking, clEnqueueReadImage does not return until the buffer data has been read and copied into memory pointed to by mem.<BR>
<BR>
If BlockingRead is false i.e. map operation is non-blocking, clEnqueueReadImage queues a non-blocking read command and returns. The contents of the buffer that mem points to cannot be used until the read command has completed. The event argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that mem points to can be used by the application.<BR>
<BR>
origin: Defines the (x, y, z) offset in pixels in the image from where to read. If image is a 2D image object, the z value given by sourceOriginZ must be 0.<BR>
<BR>
region: Defines the (width, height, depth) in pixels of the 2D or 3D rectangle being read. If image is a 2D image object, the depth value given by RegionDepth must be 1.<BR>
<BR>
RowPitch: The length of each row in bytes. This value must be greater than or equal to the element size in bytes * width. If RowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width.<BR>
<BR>
SlicePitch: Size in bytes of the 2D slice of the 3D region of a 3D image being read. This must be 0 if image is a 2D image. This value must be greater than or equal to RowPitch * height. If SlicePitch is set to 0, the appropriate slice pitch is calculated based on the RowPitch * height.<BR>
<BR>
mem: The pointer to a buffer in host memory where image data is to be read from.<BR>
<BR>
EventWaitList: Optional, Specify events that need to complete before this particular command can be executed. The events specified in event_wait_list act as synchronization points. The context associated with events in event_wait_list and command_queue must be the same.<BR>
<BR>
outEvent: Optional, Returns an event object that identifies this particular read command and can be used to query or queue a wait for this particular command to complete. event can be nil in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete.<BR>
<BR>
Calling EnqueueReadImage to read a region of the image object with the mem argument value set to HostPtr + (sourceOriginZ * image slice pitch + sourceOriginY * image row pitch + sourceOriginX * bytes per pixel), where host_ptr is a pointer to the memory region specified when the image object being read is created with kMemoryUseHostPtr, must meet the following requirements in order to avoid undefined behavior:<BR>
<BR>
<UL><LI>
All commands that use this image object have finished execution before the read command begins execution.
</LI><LI>
The RowPitch and SlicePitch argument values in EnqueueReadImage must be set to the image row pitch and slice pitch.
</LI><LI>
The image object is not mapped.
</LI><LI>
The image object is not used by any command-queue until the read command has finished execution.
</LI></UL>
<BR>
Lasterror is set.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#2">EnqueueReadImage(image as CLMemMBS, BlockingRead as boolean, sourceOriginX as Integer, sourceOriginY as Integer, sourceOriginZ as Integer, RegionWidth as Integer, RegionHeight as Integer, RegionDepth as Integer, RowPitch as Integer, SlicePitch as Integer, mem as Memoryblock, EventWaitList() as CLEventMBS, byref outEvent as CLEventMBS)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="4">EnqueueReadPicture(image as <A href="class-clmemmbs.html">CLMemMBS</A>, sourceOriginX as Integer, sourceOriginY as Integer, RegionWidth as Integer, RegionHeight as Integer, pic as picture)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>Desktop only</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to read from a 2D or 3D image object to a Xojo picture object.<BR>
<B>Example:</B> 
<div class=CodeExample translate="no">
<pre>
<span style="color: #000000;"><span style="color: #0000FF;">const</span> size = <span style="color: #336698;">500</span><br /><br /><span style="color: #800000;">// create test picture</span><br /><span style="color: #0000FF;">dim</span> pic1 <span style="color: #0000FF;">as</span> Picture = <A href="global-logombs.html">LogoMBS</A>(size)<br /><span style="color: #800000;">// create destination picture</span><br /><span style="color: #0000FF;">dim</span> pic2 <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">new</span> Picture(size, size, <span style="color: #336698;">32</span>)<br /><br /><span style="color: #800000;">// get device list</span><br /><span style="color: #0000FF;">dim</span> devices() <span style="color: #0000FF;">as</span> <A href="class-cldevicembs.html">CLDeviceMBS</A> = <A href="module-openclmbs.html">OpenCLMBS</A>.AllDevices(<A href="class-cldevicembs.html">CLDeviceMBS</A>.kDeviceTypeAll)<br /><span style="color: #0000FF;">dim</span> device <span style="color: #0000FF;">as</span> <A href="class-cldevicembs.html">CLDeviceMBS</A> = devices(<span style="color: #336698;">0</span>)<br /><br /><span style="color: #800000;">// Create context for that device</span><br /><span style="color: #0000FF;">dim</span> c <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">new</span> <A href="class-clcontextmbs.html">CLContextMBS</A>(device)<br /><br /><span style="color: #800000;">// query what format Xojo uses for pictures</span><br /><span style="color: #0000FF;">dim</span> RowPitch <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">Integer</span><br /><span style="color: #0000FF;">dim</span> format <span style="color: #0000FF;">as</span> <A href="class-climageformatmbs.html">CLImageFormatMBS</A> = <A href="module-openclmbs.html">OpenCLMBS</A>.GetPictureImageFormat(pic1, RowPitch)<br /><br /><span style="color: #800000;">// create a matching memory object</span><br /><span style="color: #0000FF;">dim</span> m <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">new</span> <A href="class-clmemmbs.html">CLMemMBS</A>(c, <A href="class-clmemmbs.html">CLMemMBS</A>.kMemoryReadWrite, format, size, size, RowPitch)<br /><br /><span style="color: #800000;">// create command queue</span><br /><span style="color: #0000FF;">dim</span> cq <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">new</span> <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A>(c, device, <span style="color: #336698;">0</span>)<br /><br /><span style="color: #800000;">// copy picture content into CLMem object</span><br />cq.EnqueueWritePicture(m, <span style="color: #336698;">0</span>, <span style="color: #336698;">0</span>, size, size, pic1)<br /><br /><span style="color: #800000;">// and copy back to second picture</span><br />cq.EnqueueReadPicture(m, <span style="color: #336698;">0</span>, <span style="color: #336698;">0</span>, size, size, pic2)<br /><br /><span style="color: #800000;">// finally display it</span><br />Backdrop = pic2</span>
</pre>
</div>
<B>Notes:</B> 
<BR>
image: Refers to a valid 2D or 3D image object.<BR>
<BR>
origin: Defines the (x, y) offset in pixels in the image from where to read. <BR>
region: Defines the (width, heigh) in pixels of the 2D or 3D rectangle being read.<BR>
<BR>
pic: The Xojo picture object to write pixel data to.<BR>
<BR>
This command is always blocking.<BR>
Lasterror is set.<BR>
<h4>Some examples using this method:</h4>
<ul translate="no">
<li><A href="example-macframeworks-opencl-openclpicturemethodtests.html">/MacFrameworks/OpenCL/OpenCL Picture Method Tests</A></li>
</ul>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="5">EnqueueTask(kernel as <A href="class-clkernelmbs.html">CLKernelMBS</A>)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to execute a kernel on a device.<BR>
<B>Notes:</B> 
<BR>
kernel: A valid kernel object. The OpenCL context associated with kernel and command_queue must be the same.<BR>
EventWaitList: Optional, Specify events that need to complete before this particular command can be executed. If EventWaitList is not passed or empty, then this particular command does not wait on any event to complete. The events specified in EventWaitList act as synchronization points. The context associated with events in EventWaitList and <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> must be the same.<BR>
outEvent: Optional, Returns an event object that identifies this particular kernel execution instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. <BR>
<BR>
The kernel is executed using a single work-item.<BR>
<BR>
EnqueueTask is equivalent to calling EnqueueNDRangeKernel with work_dim = 1, global_work_size set to 1, and local_work_size set to 1.<BR>
Lasterror is set.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#6">EnqueueTask(kernel as CLKernelMBS, EventWaitList() as CLEventMBS, byref outEvent as CLEventMBS)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="6">EnqueueTask(kernel as <A href="class-clkernelmbs.html">CLKernelMBS</A>, EventWaitList() as <A href="class-cleventmbs.html">CLEventMBS</A>, byref outEvent as <A href="class-cleventmbs.html">CLEventMBS</A>)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to execute a kernel on a device.<BR>
<B>Notes:</B> 
<BR>
kernel: A valid kernel object. The OpenCL context associated with kernel and command_queue must be the same.<BR>
EventWaitList: Optional, Specify events that need to complete before this particular command can be executed. If EventWaitList is not passed or empty, then this particular command does not wait on any event to complete. The events specified in EventWaitList act as synchronization points. The context associated with events in EventWaitList and <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> must be the same.<BR>
outEvent: Optional, Returns an event object that identifies this particular kernel execution instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. <BR>
<BR>
The kernel is executed using a single work-item.<BR>
<BR>
EnqueueTask is equivalent to calling EnqueueNDRangeKernel with work_dim = 1, global_work_size set to 1, and local_work_size set to 1.<BR>
Lasterror is set.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#5">EnqueueTask(kernel as CLKernelMBS)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="7">EnqueueUnmapMemObject(buffer as <A href="class-clmemmbs.html">CLMemMBS</A>, mem as Memoryblock)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to unmap a previously mapped region of a memory object.<BR>
<B>Notes:</B> 
<BR>
memobj: A valid memory object. The OpenCL context associated with <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> and memobj must be the same.<BR>
<BR>
mem: The host address returned by a previous call to EnqueueMapBuffer or EnqueueMapImage for memobj. Do not use this memoryblock after it has been unmapped.<BR>
<BR>
EventWaitList: Optionally, Specify events that need to complete before EnqueueUnmapMemObject can be executed. The events specified in event_wait_list act as synchronization points. The context associated with events in EventWaitList and <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> must be the same.<BR>
<BR>
outEvent: Optionally, Returns an event object that identifies this particular copy command and can be used to query or queue a wait for this particular command to complete. <BR>
<BR>
Reads or writes from the host using the pointer returned by EnqueueMapBuffer or EnqueueMapImage are considered to be complete.<BR>
<BR>
EnqueueMapBuffer and EnqueueMapImage increments the mapped count of the memory object. The initial mapped count value of a memory object is zero. Multiple calls to EnqueueMapBuffer or EnqueueMapImage on the same memory object will increment this mapped count by appropriate number of calls. EnqueueUnmapMemObject decrements the mapped count of the memory object.<BR>
<BR>
EnqueueMapBuffer and clEnqueueMapImage act as synchronization points for a region of the memory object being mapped.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#8">EnqueueUnmapMemObject(buffer as CLMemMBS, mem as Memoryblock, EventWaitList() as CLEventMBS, byref outEvent as CLEventMBS)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="8">EnqueueUnmapMemObject(buffer as <A href="class-clmemmbs.html">CLMemMBS</A>, mem as Memoryblock, EventWaitList() as <A href="class-cleventmbs.html">CLEventMBS</A>, byref outEvent as <A href="class-cleventmbs.html">CLEventMBS</A>)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to unmap a previously mapped region of a memory object.<BR>
<B>Notes:</B> 
<BR>
memobj: A valid memory object. The OpenCL context associated with <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> and memobj must be the same.<BR>
<BR>
mem: The host address returned by a previous call to EnqueueMapBuffer or EnqueueMapImage for memobj. Do not use this memoryblock after it has been unmapped.<BR>
<BR>
EventWaitList: Optionally, Specify events that need to complete before EnqueueUnmapMemObject can be executed. The events specified in event_wait_list act as synchronization points. The context associated with events in EventWaitList and <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> must be the same.<BR>
<BR>
outEvent: Optionally, Returns an event object that identifies this particular copy command and can be used to query or queue a wait for this particular command to complete. <BR>
<BR>
Reads or writes from the host using the pointer returned by EnqueueMapBuffer or EnqueueMapImage are considered to be complete.<BR>
<BR>
EnqueueMapBuffer and EnqueueMapImage increments the mapped count of the memory object. The initial mapped count value of a memory object is zero. Multiple calls to EnqueueMapBuffer or EnqueueMapImage on the same memory object will increment this mapped count by appropriate number of calls. EnqueueUnmapMemObject decrements the mapped count of the memory object.<BR>
<BR>
EnqueueMapBuffer and clEnqueueMapImage act as synchronization points for a region of the memory object being mapped.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#7">EnqueueUnmapMemObject(buffer as CLMemMBS, mem as Memoryblock)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="9">EnqueueWaitForEvents(EventWaitList() as <A href="class-cleventmbs.html">CLEventMBS</A>)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a wait for a specific event or a list of events to complete before any future commands queued in the command-queue are executed.<BR>
<B>Notes:</B> 
<BR>
EventWaitList: Events specified in EventWaitList act as synchronization points.<BR>
<BR>
The context associated with events in EventWaitList and <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> must be the same.<BR>
<BR>
Lasterror is set.<BR>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="10">EnqueueWriteBuffer(buffer as <A href="class-clmemmbs.html">CLMemMBS</A>, BlockingWrite as boolean, offset as Integer, size as Integer, mem as Memoryblock, EventWaitList() as <A href="class-cleventmbs.html">CLEventMBS</A>, byref outEvent as <A href="class-cleventmbs.html">CLEventMBS</A>)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueue commands to write to a buffer object from host memory.<BR>
<B>Notes:</B> 
<BR>
buffer: Refers to a valid buffer object.<BR>
BlockingWrite: Optional, Indicates if the write operations are blocking or nonblocking.<BR>
<BR>
If blocking_write is true, the OpenCL implementation copies the data referred to by mem and enqueues the write operation in the command-queue. The memory pointed to by mem can be reused by the application after the EnqueueWriteBuffer call returns.<BR>
<BR>
If blocking_write is false, the OpenCL implementation will use mem to perform a nonblocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by mem cannot be reused by the application after the call returns. The event argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by mem can then be reused by the application.<BR>
<BR>
offset: The offset in bytes in the buffer object to write to.<BR>
size: The size in bytes of data being written.<BR>
mem: The pointer to buffer in host memory where data is to be written from.<BR>
<BR>
EventWaitList: Optional. Specifies events that need to complete before this particular command can be executed. If EventWaitList is empty or not passed, then this particular command does not wait on any event to complete. The events specified in EventWaitList act as synchronization points. The context associated with events in EventWaitList and <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> must be the same.<BR>
<BR>
outEvent: Optional. Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. <BR>
<BR>
Calling EnqueueWriteBuffer to update the latest bits in a region of the buffer object with the mem argument value set to host_ptr + offset, where host_ptr is a pointer to the memory region specified when the buffer object being written is created with CL_MEM_USE_HOST_PTR, must meet the following requirements in order to avoid undefined behavior:<BR>
<BR>
The host memory region given by (mem + offset, size) contains the latest bits when the enqueued write command begins execution.<BR>
The buffer object is not mapped.<BR>
The buffer object is not used by any command-queue until the write command has finished execution.<BR>
<BR>
Lasterror is set.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#11">EnqueueWriteBuffer(buffer as CLMemMBS, offset as Integer, size as Integer, mem as Memoryblock)</A></li>
</ul></p>
<h4>Some examples using this method:</h4>
<ul translate="no">
<li><A href="example-macframeworks-opencl-openclhelloworld.html">/MacFrameworks/OpenCL/OpenCL HelloWorld</A></li>
<li><A href="example-macframeworks-opencl-openclhelper18-openclhelper18.html">/MacFrameworks/OpenCL/OpenCL Helper 18/OpenCL Helper 18</A></li>
</ul>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="11">EnqueueWriteBuffer(buffer as <A href="class-clmemmbs.html">CLMemMBS</A>, offset as Integer, size as Integer, mem as Memoryblock)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueue commands to write to a buffer object from host memory.<BR>
<B>Notes:</B> 
<BR>
buffer: Refers to a valid buffer object.<BR>
BlockingWrite: Optional, Indicates if the write operations are blocking or nonblocking.<BR>
<BR>
If blocking_write is true, the OpenCL implementation copies the data referred to by mem and enqueues the write operation in the command-queue. The memory pointed to by mem can be reused by the application after the EnqueueWriteBuffer call returns.<BR>
<BR>
If blocking_write is false, the OpenCL implementation will use mem to perform a nonblocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by mem cannot be reused by the application after the call returns. The event argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by mem can then be reused by the application.<BR>
<BR>
offset: The offset in bytes in the buffer object to write to.<BR>
size: The size in bytes of data being written.<BR>
mem: The pointer to buffer in host memory where data is to be written from.<BR>
<BR>
EventWaitList: Optional. Specifies events that need to complete before this particular command can be executed. If EventWaitList is empty or not passed, then this particular command does not wait on any event to complete. The events specified in EventWaitList act as synchronization points. The context associated with events in EventWaitList and <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A> must be the same.<BR>
<BR>
outEvent: Optional. Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. <BR>
<BR>
Calling EnqueueWriteBuffer to update the latest bits in a region of the buffer object with the mem argument value set to host_ptr + offset, where host_ptr is a pointer to the memory region specified when the buffer object being written is created with CL_MEM_USE_HOST_PTR, must meet the following requirements in order to avoid undefined behavior:<BR>
<BR>
The host memory region given by (mem + offset, size) contains the latest bits when the enqueued write command begins execution.<BR>
The buffer object is not mapped.<BR>
The buffer object is not used by any command-queue until the write command has finished execution.<BR>
<BR>
Lasterror is set.<BR>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#10">EnqueueWriteBuffer(buffer as CLMemMBS, BlockingWrite as boolean, offset as Integer, size as Integer, mem as Memoryblock, EventWaitList() as CLEventMBS, byref outEvent as CLEventMBS)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="12">EnqueueWriteImage(image as <A href="class-clmemmbs.html">CLMemMBS</A>, BlockingWrite as boolean, sourceOriginX as Integer, sourceOriginY as Integer, sourceOriginZ as Integer, RegionWidth as Integer, RegionHeight as Integer, RegionDepth as Integer, RowPitch as Integer, SlicePitch as Integer, mem as Memoryblock, EventWaitList() as <A href="class-cleventmbs.html">CLEventMBS</A>, byref outEvent as <A href="class-cleventmbs.html">CLEventMBS</A>)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to write from a 2D or 3D image object to host memory.<BR>
<B>Notes:</B> 
<BR>
image: Refers to a valid 2D or 3D image object.<BR>
<BR>
BlockingWrite: Optional. Indicates if the write operation is blocking or non-blocking.<BR>
<BR>
If BlockingWrite is true the OpenCL implementation copies the data referred to by mem and enqueues the write command in the command-queue. The memory pointed to by mem can be reused by the application after the clEnqueueWriteImage call returns. If BlockingWrite is false the OpenCL implementation will use mem to perform a nonblocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by mem cannot be reused by the application after the call returns. The event argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by mem can then be reused by the application.<BR>
<BR>
origin: Defines the (x, y, z) offset in pixels in the image from where to write or write. If image is a 2D image object, the z value given by sourceOriginZ must be 0.<BR>
<BR>
region: Defines the (width, height, depth) in pixels of the 2D or 3D rectangle being write or written. If image is a 2D image object, the depth value given by RegionDepth must be 1.<BR>
<BR>
RowPitch<BR>
The length of each row in bytes. This value must be greater than or equal to the element size in bytes * width. If RowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width.<BR>
<BR>
RowPitch: Size in bytes of the 2D slice of the 3D region of a 3D image being written. This must be 0 if image is a 2D image. This value must be greater than or equal to RowPitch * height. If SlicePitch is set to 0, the appropriate slice pitch is calculated based on the RowPitch * height.<BR>
<BR>
mem: The pointer to a buffer in host memory where image data is to be written to.<BR>
<BR>
EventWaitList: Optional. Specify events that need to complete before this particular command can be executed. The events specified in event_wait_list act as synchronization points. The context associated with events in event_wait_list and command_queue must be the same.<BR>
<BR>
outEvent: Optional. Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. <BR>
<BR>
Calling EnqueueWriteImage to update the latest bits in a region of the image object with the mem argument value set to mem + (sourceOriginZ * image slice pitch + sourceOriginY * image row pitch + sourceOriginX * bytes per pixel), where mem is a pointer to the memory region specified when the image object being written is created with kMemoryUseHostPtr, must meet the following requirements in order to avoid undefined behavior:<BR>
<BR>
<UL><LI>
The host memory region being written contains the latest bits when the enqueued write command begins execution.
</LI><LI>
The RowPitch and SlicePitch argument values in EnqueueWriteImage must be set to the image row pitch and slice pitch.
</LI><LI>
The image object is not mapped.
</LI><LI>
The image object is not used by any command-queue until the write command has finished execution.
</UL>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#13">EnqueueWriteImage(image as CLMemMBS,sourceOriginX as Integer, sourceOriginY as Integer, sourceOriginZ as Integer, RegionWidth as Integer, RegionHeight as Integer, RegionDepth as Integer, RowPitch as Integer, SlicePitch as Integer, mem as Memoryblock)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="13">EnqueueWriteImage(image as <A href="class-clmemmbs.html">CLMemMBS</A>,sourceOriginX as Integer, sourceOriginY as Integer, sourceOriginZ as Integer, RegionWidth as Integer, RegionHeight as Integer, RegionDepth as Integer, RowPitch as Integer, SlicePitch as Integer, mem as Memoryblock)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to write from a 2D or 3D image object to host memory.<BR>
<B>Notes:</B> 
<BR>
image: Refers to a valid 2D or 3D image object.<BR>
<BR>
BlockingWrite: Optional. Indicates if the write operation is blocking or non-blocking.<BR>
<BR>
If BlockingWrite is true the OpenCL implementation copies the data referred to by mem and enqueues the write command in the command-queue. The memory pointed to by mem can be reused by the application after the clEnqueueWriteImage call returns. If BlockingWrite is false the OpenCL implementation will use mem to perform a nonblocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by mem cannot be reused by the application after the call returns. The event argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by mem can then be reused by the application.<BR>
<BR>
origin: Defines the (x, y, z) offset in pixels in the image from where to write or write. If image is a 2D image object, the z value given by sourceOriginZ must be 0.<BR>
<BR>
region: Defines the (width, height, depth) in pixels of the 2D or 3D rectangle being write or written. If image is a 2D image object, the depth value given by RegionDepth must be 1.<BR>
<BR>
RowPitch<BR>
The length of each row in bytes. This value must be greater than or equal to the element size in bytes * width. If RowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width.<BR>
<BR>
RowPitch: Size in bytes of the 2D slice of the 3D region of a 3D image being written. This must be 0 if image is a 2D image. This value must be greater than or equal to RowPitch * height. If SlicePitch is set to 0, the appropriate slice pitch is calculated based on the RowPitch * height.<BR>
<BR>
mem: The pointer to a buffer in host memory where image data is to be written to.<BR>
<BR>
EventWaitList: Optional. Specify events that need to complete before this particular command can be executed. The events specified in event_wait_list act as synchronization points. The context associated with events in event_wait_list and command_queue must be the same.<BR>
<BR>
outEvent: Optional. Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. <BR>
<BR>
Calling EnqueueWriteImage to update the latest bits in a region of the image object with the mem argument value set to mem + (sourceOriginZ * image slice pitch + sourceOriginY * image row pitch + sourceOriginX * bytes per pixel), where mem is a pointer to the memory region specified when the image object being written is created with kMemoryUseHostPtr, must meet the following requirements in order to avoid undefined behavior:<BR>
<BR>
<UL><LI>
The host memory region being written contains the latest bits when the enqueued write command begins execution.
</LI><LI>
The RowPitch and SlicePitch argument values in EnqueueWriteImage must be set to the image row pitch and slice pitch.
</LI><LI>
The image object is not mapped.
</LI><LI>
The image object is not used by any command-queue until the write command has finished execution.
</UL>
<p>See also:<ul>
<li><A href="opencl-clcommandqueuembs-method1.html#12">EnqueueWriteImage(image as CLMemMBS, BlockingWrite as boolean, sourceOriginX as Integer, sourceOriginY as Integer, sourceOriginZ as Integer, RegionWidth as Integer, RegionHeight as Integer, RegionDepth as Integer, RowPitch as Integer, SlicePitch as Integer, mem as Memoryblock, EventWaitList() as CLEventMBS, byref outEvent as CLEventMBS)</A></li>
</ul></p>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="14">EnqueueWritePicture(image as <A href="class-clmemmbs.html">CLMemMBS</A>, sourceOriginX as Integer, sourceOriginY as Integer, RegionWidth as Integer, RegionHeight as Integer, pic as picture)</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>Desktop only</td>
</tr>
</table>
<B>Function:</B> 
Enqueues a command to write from a 2D or 3D image object to a Xojo Picture.<BR>
<B>Example:</B> 
<div class=CodeExample translate="no">
<pre>
<span style="color: #000000;"><span style="color: #0000FF;">const</span> size = <span style="color: #336698;">500</span><br /><br /><span style="color: #800000;">// create test picture</span><br /><span style="color: #0000FF;">dim</span> pic1 <span style="color: #0000FF;">as</span> Picture = <A href="global-logombs.html">LogoMBS</A>(size)<br /><span style="color: #800000;">// create destination picture</span><br /><span style="color: #0000FF;">dim</span> pic2 <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">new</span> Picture(size, size, <span style="color: #336698;">32</span>)<br /><br /><span style="color: #800000;">// get device list</span><br /><span style="color: #0000FF;">dim</span> devices() <span style="color: #0000FF;">as</span> <A href="class-cldevicembs.html">CLDeviceMBS</A> = <A href="module-openclmbs.html">OpenCLMBS</A>.AllDevices(<A href="class-cldevicembs.html">CLDeviceMBS</A>.kDeviceTypeAll)<br /><span style="color: #0000FF;">dim</span> device <span style="color: #0000FF;">as</span> <A href="class-cldevicembs.html">CLDeviceMBS</A> = devices(<span style="color: #336698;">0</span>)<br /><br /><span style="color: #800000;">// Create context for that device</span><br /><span style="color: #0000FF;">dim</span> c <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">new</span> <A href="class-clcontextmbs.html">CLContextMBS</A>(device)<br /><br /><span style="color: #800000;">// query what format Xojo uses for pictures</span><br /><span style="color: #0000FF;">dim</span> RowPitch <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">Integer</span><br /><span style="color: #0000FF;">dim</span> format <span style="color: #0000FF;">as</span> <A href="class-climageformatmbs.html">CLImageFormatMBS</A> = <A href="module-openclmbs.html">OpenCLMBS</A>.GetPictureImageFormat(pic1, RowPitch)<br /><br /><span style="color: #800000;">// create a matching memory object</span><br /><span style="color: #0000FF;">dim</span> m <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">new</span> <A href="class-clmemmbs.html">CLMemMBS</A>(c, <A href="class-clmemmbs.html">CLMemMBS</A>.kMemoryReadWrite, format, size, size, RowPitch)<br /><br /><span style="color: #800000;">// create command queue</span><br /><span style="color: #0000FF;">dim</span> cq <span style="color: #0000FF;">as</span> <span style="color: #0000FF;">new</span> <A href="class-clcommandqueuembs.html">CLCommandQueueMBS</A>(c, device, <span style="color: #336698;">0</span>)<br /><br /><span style="color: #800000;">// copy picture content into CLMem object</span><br />cq.EnqueueWritePicture(m, <span style="color: #336698;">0</span>, <span style="color: #336698;">0</span>, size, size, pic1)<br /><br /><span style="color: #800000;">// and copy back to second picture</span><br />cq.EnqueueReadPicture(m, <span style="color: #336698;">0</span>, <span style="color: #336698;">0</span>, size, size, pic2)<br /><br /><span style="color: #800000;">// finally display it</span><br />Backdrop = pic2</span>
</pre>
</div>
<B>Notes:</B> 
<BR>
image: Refers to a valid 2D or 3D image object.<BR>
<BR>
BlockingWrite: Optional. Indicates if the write operation is blocking or non-blocking.<BR>
<BR>
origin: Defines the (x, y) offset in pixels in the image from where to write or write. <BR>
<BR>
region: Defines the (width, height) in pixels of the 2D or 3D rectangle being write or written. <BR>
<BR>
pic: The target Xojo picture object. This must match in the image format for the image object and the size you specified in region.<BR>
<BR>
This operation is always performed blocked.<BR>
Lasterror is set.<BR>
<h4>Some examples using this method:</h4>
<ul translate="no">
<li><A href="example-macframeworks-opencl-openclpicturemethodtests.html">/MacFrameworks/OpenCL/OpenCL Picture Method Tests</A></li>
</ul>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="15">Finish</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Blocks until all previously queued OpenCL commands in a command-queue are issued to the associated device and have completed.<BR>
<B>Notes:</B> 
<BR>
Blocks until all previously queued OpenCL commands in command_queue are issued to the associated device and have completed.<BR>
<BR>
Finish does not return until all queued commands in command_queue have been processed and completed. clFinish is also a synchronization point.<BR>
<BR>
Lasterror is set.<BR>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="16">Flush</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Issues all previously queued OpenCL commands in a command-queue to the device associated with the command-queue.<BR>
<B>Notes:</B> 
<BR>
Issues all previously queued OpenCL commands in command_queue to the device associated with command_queue.<BR>
<BR>
Flush only guarantees that all queued commands to command_queue get issued to the appropriate device. There is no guarantee that they will be complete after Flush returns.<BR>
<BR>
Lasterror is set.<BR>
<BR>
Any blocking commands queued in a command-queue such as EnqueueReadImage or EnqueueReadBuffer with BlockingRead set to true, EnqueueWriteImage or EnqueueWriteBuffer with BlockingWrite set to true, EnqueueMapImage or EnqueueMapBuffer with BlockingMap set to true or WaitForEvents perform an implicit flush of the command-queue.<BR>
<BR>
To use event objects that refer to commands enqueued in a command-queue as event objects to wait on by commands enqueued in a different command-queue, the application must call a Flush or any blocking commands that perform an implicit flush of the command-queue where the commands that refer to these event objects are enqueued.<BR>
Lasterror is set.<BR>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="17">Properties as UInt32</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Return the currently specified properties for the command-queue. <BR>
<B>Notes:</B> 
Lasterror is set.<BR>
</div>
<div class="M">
<b><a href="class-clcommandqueuembs.html">CLCommandQueueMBS</a>.<A name="18">ReferenceCount as UInt32</A></b><br>

<table cellpadding=3>
<tr>
<td class=grau>Type</td>
<td class=grau>Topic</td>
<td class=grau>Plugin</td>
<td class=grau>Version</td>
<td class=grau>macOS</td>
<td class=grau>Windows</td>
<td class=grau>Linux</td>
<td class=grau>iOS</td>
<td class=grau>Targets</td>
</tr>
<tr>
<td class=grau>method</td>
<td class=grau><A href="topic-opencl.html" translate="no">OpenCL</A></td>
<td class=grau><a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a></td>
<td class=grau><a href="newinversion111.shtml" class=version>11.1</a></td>
<td class=grau>&#9989; Yes</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#10060; No</td>
<td class=grau>&#9989; Yes</td>
<td class=grau>All</td>
</tr>
</table>
<B>Function:</B> 
Return the command-queue reference count.<BR>
<B>Notes:</B> 
Lasterror is set.<BR>
</div>
<p>
<a href="opencl-clcommandqueuembs-method.html">Previous items</a>
 
</p>
<p>The items on this page are in the following plugins: <a href="plugins-mbsmacframeworksplugin.html">MBS MacFrameworks Plugin</a>.</p>
<!-- Ende Content-->

<br>
<div style="width: 200pt; margin: 0pt; padding: 5pt; border-color:#ccc; border-style:solid; background-color: #eee; border-width: 2pt; border-radius: 10pt; " lang="en">
&#128172; <a href="https://www.monkeybreadsoftware.com/feedback/?what=xojo&path=opencl-clcommandqueuembs-method1">Ask a question or report a problem</a>
</div>

</BODY>
</HTML>

